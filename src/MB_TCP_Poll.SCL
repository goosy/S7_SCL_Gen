FUNCTION_BLOCK "MB_TCP_Poll"
TITLE='modbusTCP 轮询'
VERSION:'1.1'
KNOW_HOW_PROTECT
AUTHOR:Goosy
NAME:MBTPoll
FAMILY:GoosyLib

VAR_INPUT
    TCON_Parameters : STRUCT
        block_length : WORD  := W#16#40;    //#!TCON config!#
        id : WORD  := W#16#1;
        connection_type : BYTE  := B#16#11;
        active_est : BOOL := TRUE;
        local_device_id : BYTE  := B#16#2;
        local_tsap_id_len : BYTE ;
        rem_subnet_id_len : BYTE ;
        rem_staddr_len : BYTE  := B#16#4;
        rem_tsap_id_len : BYTE ;
        next_staddr_len : BYTE ;
        local_tsap_id : ARRAY  [1 .. 16 ] OF BYTE  := B#16#0;
        rem_subnet_id : ARRAY  [1 .. 6 ] OF BYTE  := B#16#0;
        rem_staddr : ARRAY  [1 .. 6 ] OF BYTE  := B#16#C0, B#16#A8, B#16#0, B#16#1;
        rem_tsap_id : ARRAY  [1 .. 16 ] OF BYTE  := B#16#1, B#16#F6;
        next_staddr : ARRAY  [1 .. 6 ] OF BYTE  := B#16#0;
        spare : WORD ;    //#!TCON config!#
    END_STRUCT ;
    intervalTime : TIME := T#200MS;   // 单次询问的间隔时间 (TCP协议无需考量应答时间)
    overTimes : INT := 32; // 单次询问的回应时间大于间隔时间的overTimes倍，判定超时，该设备数据标记无效
    DATA : ANY ; // 轮询定义系列数据区
    sendP_S AT DATA: STRUCT  // Define ANY structure
        SyntaxID: BYTE := 16#10;
        DataType: BYTE := 16#2;
        DataCount: INT ;
        DB_Nummer: INT ;
        Byte_Pointer: DWORD := dw#16#84000000;
    END_STRUCT;
    buff : ANY; // 接收缓冲区
    recvP_S AT buff : STRUCT  // Define ANY structure
        SyntaxID: BYTE := 16#10;
        DataType: BYTE := 16#2;
        DataCount: INT ;
        DB_Nummer: INT ;
        Byte_Pointer: DWORD := dw#16#84000000;
    END_STRUCT;
END_VAR

VAR_IN_OUT
END_VAR

VAR_OUTPUT
    OnReceive : BOOL ; //指示当前周期收到数据
    receiveDB : INT ; //当前已接收数据块号
    receiveDBB : INT ; //当前已接收数据开始地址
    receiveLEN : INT ; //接收长度
END_VAR

VAR
    conTrigger : BOOL ; // 建立TCP连接触发器
    sendTrigger : BOOL ; // TCP发送触发器
    recvTrigger : BOOL := TRUE; // TCP接收触发器
    disconTrigger: BOOL ; // 断开TCP连接触发器
    initialized : BOOL ; // 输入已初始化
    transIndex : INT ; // 第几轮
    transLength : INT ; // 轮询个数
    pollBase : INT ; // 轮询块中轮询开始位置
    buffBase : INT ; // 缓冲块中缓冲开始位置
    TCON_ID : TCON ;
    TSEND_ID : TSEND ;
    TRCV_ID : TRCV ;
    TDISCON_ID : TDISCON ;
    TimerON : TON ;
    waitCount : ARRAY[0..31] OF INT ;
END_VAR

VAR_TEMP
    poll_DBNO : WORD ;
    buff_DBNO : WORD ;
    sendDBB : INT ;
    sendFunction : BYTE ;
    recvDB : WORD ;
    recvDBB : INT ;
    recvIndex : INT ; // 接收数据对应的轮询号
    recvIndexOffset : INT ; // 接收轮询对应在轮询块中的偏移量
    recvMBAPProtocol : WORD ;
    recvLen : INT;
    recvFunction : BYTE ;
    copyIndex : INT ; // 数据复制指针
END_VAR

BEGIN
    // 初始化
    IF NOT initialized THEN
        IF (sendP_S.DB_Nummer = 0)
            OR (sendP_S.DataType <> B#16#2)
            OR ((sendP_S.Byte_Pointer AND DW#16#ff000000) <> DW#16#84000000) THEN
            RETURN;
        END_IF;
        IF (recvP_S.DB_Nummer = 0)
            OR (recvP_S.DataType <> B#16#2)
            OR ((recvP_S.Byte_Pointer AND DW#16#ff000000) <> DW#16#84000000) THEN
            RETURN;
        END_IF;
        transIndex := 0;
        pollBase := DWORD_TO_INT(SHR(IN := sendP_S.Byte_Pointer, N := 3));
        buffBase := DWORD_TO_INT(SHR(IN := recvP_S.Byte_Pointer, N := 3));
        transLength := sendP_S.DataCount/16;
        sendP_S.DataCount := 12;
        initialized := TRUE;
    END_IF;

    // 范围检查
    IF transIndex < 0 OR transIndex >= transLength THEN
        transIndex := 0;
    END_IF;

    TCON_ID (
        REQ                      := conTrigger,
        ID                       := TCON_Parameters.id,
        CONNECT                  := TCON_Parameters);

    // 发送
    sendDBB := transIndex * 16 + pollBase;
    sendP_S.Byte_Pointer := INT_TO_DWORD(sendDBB * 8) OR DW#16#84000000;
    poll_DBNO := INT_TO_WORD(sendP_S.DB_Nummer);
    WORD_TO_BLOCK_DB(poll_DBNO).DW[sendDBB] := INT_TO_WORD(1000 + transIndex); //MBAP_seq
    WORD_TO_BLOCK_DB(poll_DBNO).DW[sendDBB+2] := W#16#0; // MBAP_protocol
    WORD_TO_BLOCK_DB(poll_DBNO).DW[sendDBB+4] := W#16#6; // MBAP_length
    TSEND_ID (
        REQ                      := sendTrigger,
        ID                       := TCON_Parameters.id,
        LEN                      := 12,
        DATA                     := DATA);

    // 接收
    TRCV_ID (
        EN_R                     := recvTrigger,
        ID                       := TCON_Parameters.id,
        DATA                     := buff);

    TDISCON_ID (
        REQ                      := disconTrigger,
        ID                       := TCON_Parameters.id);

    // 接收处理
    OnReceive := FALSE;
    IF TRCV_ID.NDR THEN
        buff_DBNO := INT_TO_WORD(recvP_S.DB_Nummer); // buff 所在的DB号
        recvIndex := WORD_TO_INT(WORD_TO_BLOCK_DB(buff_DBNO).DW[buffBase])-1000; // 接收缓冲对应的轮询号
        recvIndexOffset := recvIndex * 16 + pollBase;
        recvMBAPProtocol := WORD_TO_BLOCK_DB(buff_DBNO).DW[buffBase+2];
        recvLen := WORD_TO_INT(WORD_TO_BLOCK_DB(buff_DBNO).DW[buffBase+4]);
        recvFunction := WORD_TO_BLOCK_DB(buff_DBNO).DB[buffBase+7];
        sendFunction := WORD_TO_BLOCK_DB(poll_DBNO).DB[recvIndexOffset + 7];
        recvDB := WORD_TO_BLOCK_DB(poll_DBNO).DW[recvIndexOffset + 12];
        recvDBB := WORD_TO_INT(WORD_TO_BLOCK_DB(poll_DBNO).DW[recvIndexOffset + 14]);
        // 接收成功时处理
        IF recvMBAPProtocol = w#16#0 AND recvLen > 3 AND recvFunction = sendFunction THEN
            waitCount[recvIndex] := 0;
            WORD_TO_BLOCK_DB(recvDB).DX[recvDBB,0] := TRUE; // 设置设备正常标志
            WORD_TO_BLOCK_DB(recvDB).DX[recvDBB,1] := FALSE; // 设置设备无效标志
            FOR copyIndex := 1 TO recvLen BY 1 DO
                WORD_TO_BLOCK_DB(recvDB).DB[recvDBB+copyIndex] := WORD_TO_BLOCK_DB(buff_DBNO).DB[buffBase+copyIndex+5];
            END_FOR;
            OnReceive := TRUE;
            receiveDB := WORD_TO_INT(recvDB);
            receiveDBB := recvDBB;
            receiveLEN := recvLen;
        ELSE
            WORD_TO_BLOCK_DB(recvDB).DX[recvDBB,0] := FALSE; // 设置设备正常标志;
            WORD_TO_BLOCK_DB(recvDB).DX[recvDBB,1] := TRUE; // 设置设备无效标志
        END_IF;
    END_IF;
    IF waitCount[transIndex] > overTimes THEN // 超时处理
        recvDB := WORD_TO_BLOCK_DB(poll_DBNO).DW[sendDBB+12];
        recvDBB := WORD_TO_INT(WORD_TO_BLOCK_DB(poll_DBNO).DW[sendDBB+14]);
        WORD_TO_BLOCK_DB(recvDB).DX[recvDBB,0] := FALSE;// 设备不正常
        WORD_TO_BLOCK_DB(recvDB).DX[recvDBB,1] := TRUE; // 设置设备无效标志
    END_IF;

    // 启动定时
    TimerON(IN := sendTrigger, PT := intervalTime);
    IF TimerON.Q THEN
        waitCount[transIndex] := waitCount[transIndex] + 1;
        transIndex := transIndex + 1;
        sendTrigger := FALSE;
        conTrigger := TRUE;
        recvTrigger := TRUE;
    ELSE
        sendTrigger := TRUE;
        conTrigger := FALSE;
        disconTrigger := FALSE;
    END_IF;

END_FUNCTION_BLOCK
